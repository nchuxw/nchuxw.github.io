---
title: 'Segmentation and Enhancement of Latent Fingerprints: A Coarse to Fine Ridge Structure Dictionary'
date: 2021-01-27 14:00:00
categories: 论文解读
tags: [论文, 指纹识别]
mathjax: true
---

[论文原文下载链接](https://cdn.jsdelivr.net/gh/stxw/stxw.github.io/documnets/papers/Segmentation_and_Enhancement_of_Latent_Fingerprints.pdf)

# Introduction
&emsp;&emsp;潜在指纹(或简称“潜指纹”或“指印”)指的是某人在不小心触摸或手握过的物品表面上留下的指纹，通常出现在犯罪现场。与在参与模式下获得的滚动和平面指纹(或样本指纹)相比，潜在指纹的脊线结构通常质量较差，包含背景噪声和非线性失真(见图1)。由于这些因素的影响，潜指纹识别(潜指纹对样本匹配)的准确性远远低于样本指纹(样本对样本匹配)的准确性。作为一个例子，在上NIST评估，在10,000个平面指纹的后台数据库上，表现最好的自动指纹识别系统(AFIS)取得了99.4%的1级鉴定率；用1114个潜指纹在包含100,000个样本指纹后台数据库上，表现最好的商业潜指纹匹配器只能达到63.4%的1级鉴定率。图2显示了滚动到滚动指纹匹配和潜指纹到滚动指纹匹配的示例。在这些例子中，滚动指纹的特征是由AFIS自动提取的，而潜在指纹的特征是人工标记的。
&emsp;&emsp;如何自动提取潜指纹特征，特别是质量较差的潜指纹特征，是潜指纹特征识别中一个具有挑战性的问题。鉴于自动特征提取的难度，目前的做法是对潜在指纹的各种特征(如感兴趣区域(ROI)、奇异点和细节)进行手工标记。然而，潜指纹检测中的人为因素问题引起了对重复性和可靠性的关注。例如，一个特定的特征类型(例如，细节点)的标记，由不同的潜指纹检测员，甚至是同一个检测员在不同的时间，可能会给出不同的结果。NIST的一项研究表明，潜指纹匹配器的准确性受潜指纹检查标记的精度影响很大，特别是当潜指纹图像本身不能用于匹配时。影响人工标记性能的因素之一是，因为繁重的案件工作，潜指纹检测员经常在极端的时间压力下工作。研究表明，在指纹比对时间有限的情况下，潜指纹检测员更有可能在潜指纹和它的配对滚动指纹之间做出不确定的匹配决定。基于潜指纹匹配引起的身份错误中，最臭名昭著的案件之一是布兰登·梅菲尔德案件。无罪项目也报告了其他错误识别的案例。FBI下一代识别(NGI)的发展重点之一是支持lights-out功能的潜指纹识别(lights-out识别指的是一种自动识别系统，在这种系统中，查询指纹图像作为输入，输出由一个简短的候选列表组成)。这种lights-out功能的一个重要组成部分是开发一个全自动的潜指纹特征提取模块。为了(i)增加潜指纹匹配系统的吞吐量，(ii)提高潜指纹特征提取的可重复性，(iii)增加潜指纹提取的特征与AFIS(自动指纹识别系统)中参考指纹提取的特征之间的兼容性，这是非常可取的。
&emsp;&emsp;一个AFIS，无论是用于滚动/平面指印匹配还是潜指纹匹配，通常包含许多模块，包括感兴趣区域(ROI)分割(将指纹从背景中分离出来)、增强、特征提取和匹配。分割，特别是潜指纹的分割，是至关重要的，可以避免提取特征(如，细节点)在嘈杂的背景中的影响。增强脊线和谷线结构，去除前景区域的噪声是提取准确特征的关键。基于Gabor滤波的指纹增强能自适应地提高脊谷结构的清晰度；滤波器是根据局部脊线的方向和频率进行调整的。因此，对于潜指纹增强，获得良好的脊线方向和频率场估计是至关重要的。
&emsp;&emsp;此处省略1万字....(太长了，想直接看主要内容)

&emsp;&emsp;图3显示了一个潜在指纹示例，在该示例中，本文提出的分割和增强提高了COTS潜指纹匹配器的潜指纹识别性能(检索等级)。本文的主要贡献如下：
1. 提出了一种基于脊线结构字典的潜指纹特征分割和增强算法。这个字典从高质量的指纹块中学习而来。
2. 一个指纹块的脊线质量定义为，该块与其从学习到的脊线结构字典中重建的块，的结构相似度。通过对图像的重建，可以估计出图像的方向和频率场。
3. 为了兼顾鲁棒性和准确性，提出了一种基于64×64和32×32两种分辨率字典的从粗到精的策略。
4. 所提出的分割和增强算法优于已发布的算法，并能显著提高最先进的商用潜指纹匹配器在两个潜指纹数据库(NIST SD27和WVU DB)上的性能。

本文的其余部分组织如下：第二节给出了所提算法的细节。实验结果报告在第3节。最后在第四部分给出了结论和未来的研究方向。

# 提出的算法
## 算法简介
&emsp;&emsp;本算法包括离线字典学习阶段和在线词典分割和增强阶段(图4)。在离线阶段，学习两种字典：
1. 一个块大小为64×64像素的粗级字典。
2. 16个块大小为32×32像素的细级字典。

这16个细的字典对应16个不同的脊线方向。采用64×64块大小的字典对脊线质量图、方向场和频率场进行粗略估计，采用16个不同方向的32×32块大小的字典对脊线质量图进行精细估计，并计算方向场和频率场。之所以在细级字典中选择的块大小为32×32像素，是因为32×32的块大概包含了500ppi指纹的两个脊线和谷线，这对结构噪声具有较强的鲁棒性。粗级字典(64×64像素)中的块大小是细级字典的两倍。
&emsp;&emsp;给定字典，在线潜指纹分割和增强包括以下步骤：
1. 潜指纹分解：通过局部总变量将输入的潜指纹分解为卡通图像(原文中用的是“cartoon”这个单词，确实是“卡通”的意思，我自己也？？？？)和纹理图像；卡通图像被丢弃了。
2. 质量图、方向和频率场的粗略估计：将纹理图像分割成大小为64×64像素的重叠块($P_L^c$)。每个块有64×48或48×64个重叠像素与它的四个相邻块相连。对每个块$p \in P_L^c$，通过正交匹配追踪[34]得到其稀疏表示和粗级字典重构的块$\hat{p}$。$p$和$\hat{p}$之间的结构相似性被定义为块的粗质量。由于重建的块$\hat{p}$一般具有清晰的脊线模式，所以可以用重建的块$\hat{p}$中的特征来代替$p$中的脊线方向和频率。在块重叠区域，通过覆盖块来获得粗质量、粗方向和频率场。
3. 质量图、方位和频率场的精确估计：纹理图像被分割成大小为32×32像素的重叠块($P_L^f$)。每个块有32×16或16×32个重叠像素与它的四个相邻块相连。对每个块$p \in P_L^f$，首先利用粗脊线方向值索引相应的细级字典。脊线质量图、方位和频率场的精确估计的计算方式和步骤2中的粗略估计相同。
4. 分割与增强：将粗质量图和细质量图相结合进行潜指纹分割。利用步骤2和3中获得的方向和频率场，对纹理图像的前景部分进行Gabor滤波，进行潜指纹增强。

## 字典学习
&emsp;&emsp;Feng等人最先提出使用字典进行指纹方向场估计。但是，他们的字典是基于方向块的，忽略了脊线结构信息。这是他们在[10]中的方法在分割和频率场估计方面不太成功的主要原因。在本节中，我们提出了脊线结构字典学习。

### 训练集的选择
&emsp;&emsp;为了构建可靠、鲁棒的指纹字典，从NIST SD4的滚动图像中选取了大量高质量的指纹块。选择的图像块如下所示：
1. 高质量指纹的选择：使用NIST指纹图像质量(NFIQ，猜测是是个质量评估工具)选择NIST SD4中高质量(即NFIQ < 3)的500个指纹。
2. 高质量块的选择：使用MINDTCT(NIST指纹图像软件(NFIS))来估计1中选择的指纹的方向场和每个块的脊线质量图。脊线质量图为每个块提供了5个质量等级中的一个(4是最高质量，0是最低质量)。对于粗级字典，采用步长为8像素滑动窗口的方法，在指纹图像上选择一组大小为64×64像素的图像块$P^c$；如果图像块的平均质量值大于预定义的阈值$T$($T$设为3.75)，则该块被纳入训练集。对于方向特定的细级字典，根据脊线方向构造16组指纹块$P^F_i,i = 1,···,16$。对于$P^f_i$，在指纹图像上滑动一个32×32的窗口；当一个块满足以下两个条件时：i)块的平均质量值大于$T$, ii)块的平均脊线方向在$[ (i - 1) \times \frac{\pi}{6}, i \times \frac{\pi}{6} )$范围内，则选择该块。
3. 向量归一化：对训练集中的每个块$p$通过公式(1)进行归一化，然后通过行串接将其转换为向量。
$$ \tilde{p} = (p - \mu_p) / \sigma_p \tag{1}
$$ 其中$\mu_p$是块$p$的平均强度，$\sigma_p$是块$p$的标准差。

&emsp;&emsp;用$ P^c = \{ p^c_j \}^{N^c}_{j=1} $表示粗级字典的训练集，其中$N^c$表示在$P^c$中训练块的数量，用$P^f_i = \{ p^f_{i,j} \}^{N^f_i}_{j=1} $，$i = 1,· · ·,16$，表示16个细级字典的训练集，其中$N^f_i$表示第$i$个特定脊线方向字典的训练块数量。为了平衡效率和准确性，我们从$P^c$中随机选取80,000个块，从每个$P^f_i$中随机选取10,000个块进行字典学习。

### 字典学习
&emsp;&emsp;不失一般性，对于一个训练集$ P = \{ p_j \}^{N^c}_{j=1} $，字典学习的目标是构建一个大小为$N_P \times N_D$字典$D$，$D$需要提供$P$中每个块的最佳稀疏表示, $N_P$是$P$中块的维度，$N_D$是字典里$D$中元素的数量。一个典型的字典学习目标函数是：
$$ \min_{D, \Gamma}\| P - D\Gamma \|_F^2 \ \ s.t.\forall j, \ \ \|\gamma_j\|_0 \leq T_0, \tag{2} 
$$ 其中$\gamma_j$是大小为$N_D \times N$的矩阵$\Gamma$的第$j$列，$\|\cdot\|_0$是计算表示中非零项个数的$l^0$范数，$T_0$是预定的非零项个数，$\|\cdot\|_F$是Frobenius范数。字典学习的有效算法之一是K-SVD，它通过以下两个阶段的迭代来最小化公式(2)中的目标函数。
- 稀疏编码阶段：在固定字典$D$下，通过求解以下优化问题，得到$P$中每个块$p_j$的系数向量$\gamma_j$的表示：
$$
\min_{\gamma_j} \| p_j - D_{\gamma_j} \|_2^2 \ s.t. \ \| \gamma_j \|_0 \leq T_0, j = 1,2,...,N, \tag{3}
$$
- 字典更新阶段：这一阶段通过奇异值分解(SVD)每次更新字典$D$的一列，同时固定$D$的所有其他列，从而减小公式(2)中的目标函数。

使用离散余弦变换(DCT)基础构造初始字典D。每个字典元素学习后都通过公式(1)进行归一化。
&emsp;&emsp;以$P^c$和$P^f_i, i = 1，···，16$为训练集，共构造了17个不同的字典(粗级字典$D^c$和16个细级字典$D^f_i, i = 1，···，16$)。将粗级字典中的元素个数$N^c_D$设置为1024，将每个细级字典中的元素个数$N^f_D$设置为64。图5显示了粗级字典$D^c$中的字典元素子集，图6显示了16个细级字典中的字典元素子集。



